/*
 * Copyright (C) 2001-2002 Iowa State University
 *
 * This file is part of JML
 *
 * JML is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * JML is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JML; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: RacConstants.java,v 1.34 2007/02/03 02:04:49 delara Exp $
 */

package org.jmlspecs.ajmlrac;

import org.jmlspecs.checker.Constants;

/**
 * A set of string constants used by RAC implementation classes. The
 * convention is that a class or interface name starts with
 * <code>TN_</code> (e.g., <code>TN_SURROGATE</code>), a method name
 * prefix starts with <code>MN_</code> (e.g.,
 * <code>MN_CHECK_PRE</code>), and a variable name prefix starts with
 * <code>VN_</code> (e.g., <code>VN_DELEGEE</code>).
 *
 * @author Yoonsik Cheon
 * @version $Revision: 1.34 $
 */
public interface RacConstants extends Constants {

    // ----------------------------------------------------------------------
    // TYPE NAMES
    // ----------------------------------------------------------------------

    /** The name of the surrogate class for an interface. The
     * surrogate class is declared as a static inner classe of the
     * corresponding interface.
     *
     * @see TransInterface
     */
    String TN_SURROGATE = "JmlSurrogate";

    /** The name of the interface that all surrogate classes have to
     * implement. This interface defines a protocol for the surrogate
     * class and the implementing class to communicate with each other
     * for the dynamic delegation of assertion check methods.
     *
     * @see #TN_JMLCHECKABLE
     * @see TransInterface
     * @see org.jmlspecs.jmlrac.runtime.JMLSurrogate
     */
    String TN_JMLSURROGATE = "JMLSurrogate";

    /** The type name of a private delegee field
     * (<code>VN_DELEGEE</code>) of the surrogate class
     * (<code>TN_SURROGATE</code>) for an interface. This interface
     * defines a protocol for the surrogate class and the implementing
     * class to communicate with each other for the dynamic delegation
     * of assertion checks.  All generated classes are supposed to
     * implement this interface.
     *
     * @see #VN_DELEGEE
     * @see #TN_SURROGATE
     * @see #TN_JMLSURROGATE
     * @see org.jmlspecs.jmlrac.runtime.JMLCheckable
     * @see TransInterface
     * @see TransClass
     * @see TransType
     */
    String TN_JMLCHECKABLE = "JMLCheckable";

    /** The name of a special wrapper class that can encapsulate two
     * special values in addition to Java regular values:
     * <em>undefined</em> and <em>non-executable</em>. This type is
     * used to store pre-state values such as old variables and old
     * expressions into private fields for future references by
     * post-state assertion check methods such as postcondition check
     * methods and constraint check methods.
     *
     * @see org.jmlspecs.jmlrac.runtime.JMLRacValue
     * @see TransMethod
     * @see TransExpression
     * @see PreValueVars
     */
    String TN_JMLVALUE = "JMLRacValue";
    
    /**
     * The name of test class generated by jmlunit. A
     * jmlunit-generated test class is not compiled by jmlc.
     */
    String TN_JMLUNIT_TEST_POSTFIX = "_JML_Test";

    /**
     * The name of test case class generated by jmlunit. A
     * jmlunit-generated test case class is not compiled by jmlc.
     */
    String TN_JMLUNIT_TESTDATA_POSTFIX = "_JML_TestData";

    // ----------------------------------------------------------------------
    // METHOD NAMES
    // ----------------------------------------------------------------------

    /** The method name prefix for methods that check method
     * preconditions, often called <em>precondition check
     * methods</em>.  The name of its precondition check method for a
     * method <code>m</code> declared in a type <code>T</code>, is
     * <code>MN_CHECK_PRE + m + "$" + T</code>.
     *
     * @see PreconditionMethod
     */
    String MN_CHECK_PRE = "checkPre$";

    /** The method name prefix for methods that check normal
     * postconditions, often called <em>normal postcondition check
     * methods</em>.  The name of its normal postcondition check
     * method for a method <code>m</code> declared in a type
     * <code>T</code>, is <code>MN_CHECK_POST + m + "$" + T</code>.
     *
     * @see PostconditionMethod
     */
    String MN_CHECK_POST = "checkPost$";

    /** The method name prefix for methods that check exceptional
     * postconditions, often called <em>exceptional postcondition
     * check methods</em>.  The name of its exceptional postcondition
     * check method for a method <code>m</code> declared in a type
     * <code>T</code>, is <code>MN_CHECK_XPOST + m + "$" + T</code>.
     *
     * @see PostconditionMethod
     */
    String MN_CHECK_XPOST = "checkXPost$";

    /** The method name prefix for methods that evaluate, in the
     * pre-state, old expressions appearing in history constraints,
     * for use in the post-state by constraint check methods. For a
     * type <code>T</code>, two old expression evaluation methods are
     * generated, one for static constraints and other for non-static
     * constraints, whose names are respectively 
     * <code>MN_EVAL_OLD + "$" + T + "$" + instance</code> and
     * <code>MN_EVAL_OLD + "$" + T + "$" + static</code>.
     *
     * @see TransConstraint
     * @see TransType
     * @see TransClass
     * @see TransInterface
     */
    String MN_EVAL_OLD = "evalOldExprInHC$";

    /** The method name prefix for methods that check invariants.  For
     * a type <code>T</code>, two invariant check methods 
     * are generated, one for static invariants and the other for
     * non-static invariants, whose names are respectively
     * <code>MN_CHECK_INV + "$" + T + "$" + static</code> and
     * <code>MN_CHECK_INV + "$" + T + "$" + instance</code>.
     *
     * @see InvariantMethod
     * @see TransType
     * @see TransClass
     * @see TransInterface
     */
    String MN_CHECK_INV = "checkInv$";

    /** The method name prefix for methods that check history
     * constraints.  For a type <code>T</code>, two constraint check
     * methods are generated, one for static constraints and the other
     * for non-static constraints, whose names are respectively
     * <code>MN_CHECK_HC + "$" + T + "$" + static</code> and
     * <code>MN_CHECK_HC + "$" + T + "$" + instance</code>.
     *
     * @see ConstraintMethod
     * @see TransConstraint
     * @see TransType
     * @see TransClass
     * @see TransInterface
     */
    String MN_CHECK_HC = "checkHC$";


    /** The method name prefix for renaming original methods into
     * private internal methods. A method, <code>m</code>, of type
     * <code>T</code> is renamed into a method 
     * <code>MN_INTERNAL + "$" + m + "$" + T</code>.
     *
     * @see TransMethod
     */
    String MN_INTERNAL = "internal$";

    /** The method name prefix for access methods generated for model
     * fields. For a model field, <code>v</code>, declared in a
     * type, <code>T</code>, the name of the generated access method is
     * <code>MN_MODEL + v + "$" + T</code>. */
    String MN_MODEL = "model$";

    /** The method name prefix for spec_public and spec_protected
     * access methods generated for spec_public and spec_protected
     * fields. For a spec_public field, <code>v</code>, declared in a
     * type, <code>T</code>, the name of the generated access method
     * is <code>MN_SPEC + v + "$" + T</code>. */
    String MN_SPEC = "spec$";

    /** The variable and method name prefix for the private field and a
     * pair of access methods generated for a ghost variable. E.g.,
     * for a ghost variable, <code>v</code>, a private field of name
     * <code>MN_GHOST + v</code> is generated; also generated is the
     * same named getter and setter methods. */
    String MN_GHOST = "ghost$";

    /** The method name prefix of access methods generated for
     * spec_public and spec_protected methods. For a spec_public
     * method, <code>m</code>, declared in a type, <code>T</code>, the
     * name of the generated access method is <code>MN_SPEC_PUBLIC +
     * m + "$" + T</code>. */
    String MN_SPEC_PUBLIC = "specPublic$";

    /** The method name prefix of access methods generated for model
     * methods. For a model method, <code>m</code>, declared in a
     * type, <code>T</code>, the name of the generated access method
     * is <code>MN_MODEL_PUBLIC + m + "$" + T</code>. */
    String MN_MODEL_PUBLIC = "modelPublic$";

    /** The method name prefix for the method that saves pre-state
     * values into the private stack field (<code>VN_STACK_VAR</code>)
     * for possible recursive method calls.
     *
     * @see #VN_STACK_VAR
     * @see #MN_RESTORE_FROM
     */
    String MN_SAVE_TO = "saveTo$";

    /** The method name prefix for the method that restores pre-state
     * values from the private stack field (<code>VN_STACK_VAR</code>)
     * for possible recursive method calls.
     *
     * @see #VN_STACK_VAR
     * @see #MN_SAVE_TO
     */
    String MN_RESTORE_FROM = "restoreFrom$";

    /** The name of the internal method and the assertion check
     * methods for the constructors. E.g., <code>internal$$init$</code>
     * and <code>checkPre$$init$</code>.
     */    
    String MN_INIT = "$init$";

    // ----------------------------------------------------------------------
    // VARIABLE NAMES
    // ----------------------------------------------------------------------
    
    /** The name of a set variable that holds information about all
     * the assertion violations detected so far by the runtime
     * assertion checker. */
    String VN_ERROR_SET = "rac$where";

    String VN_PRECOND = "rac$pre";

    /** The name of a varialbe that holds the return value of the
     * method being assertion checked. */
    String VN_RESULT = "rac$result";

    /** The name of a variable that holds the exceptional result of
     * the method being assertion checked. */
    String VN_XRESULT = "rac$e"; // "rac$result" ?


    /** The name of local variables to be generated to evaluate
     * varisous JML predicates and expressions.
     *
     * @see VarGenerator#freshVar()
     */
    String VN_FREE_VAR = "rac$v";

    /** The name of variables to generate for use in catch clauses.
     *
     * @see VarGenerator#freshCatchVar()
     */
    String VN_CATCH_VAR = "rac$e";

    /** The name of a private field generated to store the pre-state
     * value of an old expression in postcoditions and history
     * constraints and an old variable appearing in a method
     * specification.
     *
     * @see VarGenerator#freshOldVar()
     */
    String VN_OLD_VAR = "rac$old";
    
    /** The name of an old var declared to represent
     * the bind to any argument of the given type.
     * This is used by XCS feature of AspectJML.
     *
     * @author Henrique Rebelo
     */
    String VN_ASPECTJ_THISJOINPOINT = "thisJoinPoint";


    /** The name of a private field generated to store the result of
     * precondition evaluation, for reference by the postcondition
     * check methods. 
     *
     * @see VarGenerator#freshPreVar()
     */
    String VN_PRE_VAR = "rac$pre";

    /** The name of a local variable generated to store the result of
     * evaluating a specification case of a postcondition
     *
     * @see VarGenerator#freshPostVar()
     */
    String VN_POST_VAR = "rac$b";

    String VN_ASSERTION = "rac$b";

    /** Name of the exception parameter. */
    String VN_EXCEPTION = "rac$e";

    /** Name of the stack variable. Pre-state values such as
     * preconditions, old variables, and old expressions are stored
     * into, and restored from this variable to make post-state
     * methods (e.g., postcondition check method) refer to right
     * pre-state values in the presence of recursive method calls.
     * 
     * @see #MN_SAVE_TO
     * @see #MN_RESTORE_FROM
     * @see VarGenerator#freshStackVar()
     */
    String VN_STACK_VAR = "rac$stack";

    /** 
     * Name of a non-static boolean field that indicates whether a
     * class instance, during its construction, has finished its
     * initialization. Here, by initialization we means the execution
     * of the instance initializers and instance field initializers
     * for the class, which is done after an explicit (or implicit)
     * super call and before the execution of the constructor body
     * (JLS 12.5). The intent here is to disable instance assertion
     * checks while an instance has not finished its initialization.
     *
     * @see #VN_CLASS_INIT
     * @see WrapperMethod#generate()
     * @see TransType#finalizeTranslation()
     */
    String VN_INIT = "rac$initialzed";

    /** 
     * Name of a static boolean field that indicates whether the
     * initialization of a class or an inteface has been completed.
     * By initialization, we mean that all static the static
     * initializers and the initializers for static fields (class
     * variables) have been executed (JLS 12.4). The intent here is to
     * disable both static and instance asssertion checks while a
     * class has not fininished its initialization.
     *
     * @see #VN_INIT
     * @see ConstructorWrapper#generate()
     * @see TransType#finalizeTranslation()
     */
    String VN_CLASS_INIT = "rac$ClassInitialized";

    /** Name of a private delegee field of a surrogate class
     *  (<code>TN_SURROGATE</code>) for an interface. The type of this
     *  field is the interface defined by the constant
     *  <code>TN_JMLCHECKABLE</code>.
     *
     * @see #TN_JMLCHECKABLE
     * @see #TN_SURROGATE
     */
    String VN_DELEGEE = "self";

    /** Name of the static field generated by the runtime assertion
     * checker to indicate the per-class runtime assertion check
     * level. If the value of this field is changed, the same change
     * should be maded to the method
     * <code>JMLChecker.setLevel(Class, int)</code> and
     * <code>JMLChecker.getLevel(Class)</code>.
     *
     * @see org.jmlspecs.jmlrac.runtime.JMLChecker#setLevel(Class, int)
     * @see org.jmlspecs.jmlrac.runtime.JMLChecker#getLevel(Class)
     */
    String VN_RAC_LEVEL = "rac$level";

    /** Name of the static final field generated by the runtime
     * assertion checker to indicate that a type is compiled with the
     * runtime asssertion check code. If the value of this field is
     * changed, the same change should be maded to the method
     * <code>JMLChecker.isRacCompiled(Class)</code>.
     *
     * @see org.jmlspecs.jmlrac.runtime.JMLChecker#isRACCompiled(Class)
     */
    String VN_RAC_COMPILED = "rac$RAC_COMPILED";

    /** 
     * Name of a boolean variable that indicates whether an instance
     * finishes its construction. I.e., a constructor has completed
     * its execution. This flag is used to prevent assertion check
     * while an object is constructed.
     *
     * @see ConstructorWrapper#generate()
     * @see WrapperMethod#generate()
     * @see TransClass#finalizeTranslation()
     */
    String VN_CONSTRUCTED = "rac$dented";
    
    // Rebelo - Constants defined for the ajmlc compiler
    
    /** The prefix of the all generated temporary aspect files.
     * @author Henrique Rebelo
     * @see TransInterface
     */
    String TN_TEMPORARY_ASPECT_FILE_NAME = "AspectJMLRac_";
    
    /** The prefix of the all generated quantifiers.
     * @author Henrique Rebelo
     */
    String CN_RAC_QUANTIFIER_ID = "$quantifier";
    
}
