// Generated from JmlMessages.msg
package org.jmlspecs.checker;

import org.multijava.util.MessageDescription;

public class JmlMessages {
//	Features not supported in AspectJML --- [[[hemr]]]
  public static final MessageDescription	NO_SUPPORT_STATIC_MODEL_FIELD_ON_INTERFACE = new MessageDescription("Static model field is not supported on interface declaration", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_STATIC_MODEL_METHOD_ON_INTERFACE = new MessageDescription("Static model method is not supported on interface declaration", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_GHOST_FIELD_STATEMENT = new MessageDescription("Ghost field is not supported", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_DEBUG_STATEMENT = new MessageDescription("Debug statement is not supported", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_UNREACHABLE_STATEMENT = new MessageDescription("Unreachable statement is not supported", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_SET_STATEMENT = new MessageDescription("Set statement is not supported", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_ASSERT_OR_ASSUME_STATEMENT = new MessageDescription("Assert or assume statement is not supported", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_LOOP_INVARIANT = new MessageDescription("Loop invariant is not supported", "AspectJML", 0);
  public static final MessageDescription	NO_SUPPORT_LOOP_VARIANT = new MessageDescription("Loop variant is not supported", "AspectJML", 0);
  // XCS messages
  public static final MessageDescription	INVALID_JOINPOINT_ARG_IDENT_XCS = new MessageDescription("The param name \"{0}\" is not allowed for the argument type org.aspectj.lang.JoinPoint in a XCS pointcut method or advice declaration", "AspectJML", 0);
  public static final MessageDescription	INVALID_JOINPOINT_ARG_IDENT = new MessageDescription("The param name \"{0}\" is not allowed for the argument type org.aspectj.lang.JoinPoint in a method declaration", "AspectJML", 0);
  public static final MessageDescription	INVALID_STATIC_POINTCUT = new MessageDescription("The static pointcut defined by the XCS pointcut method \"{0}\" is not allowed without the explicit reference to its enclosing owner type \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	PROPERTY_BASED_POINTCUT_NOT_ALLOWED = new MessageDescription("The property based name type pattern used by the XCS pointcut method \"{0}\", involving the enclosing owner type \"{1}\", is not allowed in AspectJML\"", "AspectJML", 0);
  public static final MessageDescription	INVALID_STATIC_AND_INSTANCE_POINTCUT_TOGETHER = new MessageDescription("Mixing static with instance pointcuts is not allowed in AspectJML. Hence, the XCS pointcut method \"{0}\" must use either the \"static\" modifier for all pointcuts or not", "AspectJML", 0);
  public static final MessageDescription	NO_THIS_REF_IN_STATIC_POINTCUT = new MessageDescription("The static pointcut defined by the XCS pointcut method \"{0}\" is not allowed to mention instance members in its crosscutting specifications", "AspectJML", 0);
  public static final MessageDescription	INVALID_POINTCUT_EXEC = new MessageDescription("The \"execution\" pointcut defined by the XCS pointcut method \"{0}\" is not allowed with either the option \"noExecutionSiteInstrumentation\" or \"clientAwareChecking\" enabled", "AspectJML", 0);
  public static final MessageDescription	INVALID_POINTCUT_CALL = new MessageDescription("The \"call\" pointcut defined by the XCS pointcut method \"{0}\" is not allowed if both options \"callSiteInstrumentation\" and \"clientAwareChecking\" are disabled. One of them should be enabled", "AspectJML", 0);
  public static final MessageDescription	INVALID_POINTCUT_TARGET = new MessageDescription("The \"target\" pointcut defined by the XCS pointcut method \"{0}\" is not allowed since the enclosing type is already associated with the pointcut predicate expression", "AspectJML", 0);
  public static final MessageDescription	INVALID_POINTCUT_THIS = new MessageDescription("The \"this\" pointcut defined by the XCS pointcut method \"{0}\" is not allowed since the enclosing type is already associated with the pointcut predicate expression", "AspectJML", 0);
  public static final MessageDescription	MISSING_CROSSREF_DIR = new MessageDescription("Failed to add the generated crossref-file \"{0}\" since the specified crossref dir does not exist", "AspectJML", 1);
	
  public static final MessageDescription	UNBALANCED_PAREN = new MessageDescription("Unbalanced parentheses within curly brackets", "AspectJML", 0);
  public static final MessageDescription	LOOP_STMT_EXPECTED = new MessageDescription("A loop statement is expected", "AspectJML", 0);
  public static final MessageDescription	SET_STATEMENT = new MessageDescription("An assignment expression is expected in the set statement", "AspectJML", 0);
  public static final MessageDescription	LHS_OF_ASSIGN_STATEMENT = new MessageDescription("The left-hand-side of an assignment statement must not reference a ghost field (use a set statement)", "AspectJML", 0);
  public static final MessageDescription	LHS_OF_SET_STATEMENT = new MessageDescription("The left-hand-side of the set statement must be a reference to a ghost field", "AspectJML", 0);
  public static final MessageDescription	RHS_OF_SET_STATEMENT = new MessageDescription("The right-hand-side of the set statement must not be an assignment expression.", "AspectJML", 0);
  public static final MessageDescription	MODEL_LHS_IN_ASSIGNMENT = new MessageDescription("A model variable is not allowed in the left-hand-side of an assignment expression.", "AspectJML", 0);
  public static final MessageDescription	MODEL_IN_PREFIX_EXPRESSION = new MessageDescription("A model variable is not allowed in a prefix or postfix expression.", "AspectJML", 0);
  public static final MessageDescription	REFINE_FILE_NOT_FOUND = new MessageDescription("The refined file, \"{0}\", could not be found", "AspectJML", 0);
  public static final MessageDescription	CLASS_AFTER_MEMBER = new MessageDescription("Behavioral specification for method is not followed by a method declaration; there is an intervening type specification member", "AspectJML", 0);
  public static final MessageDescription	UNUSED_METHOD_SPEC = new MessageDescription("Behavioral specification for method is not followed by a method declaration; there is a field or type declaration instead", "AspectJML", 0);
  public static final MessageDescription	NESTED_ANNOTATION = new MessageDescription("An annotation may not contain another annotation", "AspectJML", 0);
  public static final MessageDescription	ILLEGAL_MODEL_PROG_STATEMENT = new MessageDescription("A model program statement cannot appear outside of a model program", "AspectJML", 0);
  public static final MessageDescription	BAD_INITIALIZER_MODIFIERS = new MessageDescription("An initializer may not include a modifier apart from \"static\"", "AspectJML", 0);
  public static final MessageDescription	AXIOM_MODIFIERS = new MessageDescription("An axiom may not be preceded by any modifiers", "AspectJML", 0);
  public static final MessageDescription	EXTENDING_SPEC_MODIFIERS = new MessageDescription("An extending-specification may not be preceded by any modifiers", "AspectJML", 0);
  public static final MessageDescription	INVALID_LOCAL_MODIFIER = new MessageDescription("Only final, ghost, non_null and nullable modifiers are allowed in a local variable declaration but found [ {0}]", "AspectJML", 0);
  public static final MessageDescription	INVALID_PARAM_MODIFIER = new MessageDescription("Only final, non_null and nullable modifiers are allowed for formal parameters", "AspectJML", 0);
  public static final MessageDescription	METHOD_MODIFIER_MISMATCH = new MessageDescription("{0} method \"{1}\" overrides a {2} method in {3}", "AspectJML", 0);
  public static final MessageDescription	GENERIC_SPEC_CASE_MODIFIERS = new MessageDescription("An generic-spec-case may not be preceded by any modifiers", "AspectJML", 0);
  public static final MessageDescription	REDUNDANT_SPEC_MODIFIERS = new MessageDescription("An redundant specification may not be preceded by any modifiers", "AspectJML", 0);
  public static final MessageDescription	BAD_PRIVACY_MODIFIER = new MessageDescription("One of privacy modifiers (or none) is expected", "AspectJML", 0);
  public static final MessageDescription	MULTIPLE_PRIVACY_MODIFIER = new MessageDescription("A privacy modifier (public, protected or private) appears more than once", "AspectJML", 0);
  public static final MessageDescription	MISPLACED_DOT_STAR = new MessageDescription("Misplaced \".*\" in expression \"{0}\": it can only appear once and it must be at the end of the expression", "AspectJML", 0);
  public static final MessageDescription	BAD_STORE_REF_KEYWORD = new MessageDescription("The store-ref keyword {0} is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	BAD_SIMPLE_SPEC_BODY = new MessageDescription("One of simple spec body clauses is expected", "AspectJML", 0);
  public static final MessageDescription	BAD_NORMAL_SPEC_BODY = new MessageDescription("One of normal spec body clauses is expected", "AspectJML", 0);
  public static final MessageDescription	BAD_EXCEPTIONAL_SPEC_BODY = new MessageDescription("One of exceptional spec body clauses is expected", "AspectJML", 0);
  public static final MessageDescription	BAD_SIMPLE_SPEC_STATEMENT_BODY = new MessageDescription("One of simple spec statement body clauses is expected", "AspectJML", 0);
  public static final MessageDescription	BAD_ABRUPT_SPEC_BODY = new MessageDescription("One of abrupt spec body clauses is expected", "AspectJML", 0);
  public static final MessageDescription	LIGHT_WEIGHTED_EXAMPLE_SPEC = new MessageDescription("A light-weighted example specification can not have an access modifier", "AspectJML", 0);
  public static final MessageDescription	ARITHMETIC_MODE_CONFLICT = new MessageDescription("A maximum of one arithmetic mode can be specified for the code or specification of a class or method", "AspectJML", 0);
  public static final MessageDescription	NO_ASSIGNMENT_EXPRESSION = new MessageDescription("An assignment expression (e.g., =) can not be used in a specification expression", "AspectJML", 0);
  public static final MessageDescription	NO_PREFIX_EXPRESSION = new MessageDescription("A prefix expression (e.g., ++) can not be used in a specification expression", "AspectJML", 0);
  public static final MessageDescription	NO_POSTFIX_EXPRESSION = new MessageDescription("A postfix expression (e.g., ++) can not be used in a specification expression", "AspectJML", 0);
  public static final MessageDescription	FIELD_VISIBILITY = new MessageDescription("Field \"{0}\" can not be referenced in a specification context of \"{1}\" visibility", "AspectJML", 0);
  public static final MessageDescription	FIELD2_VISIBILITY = new MessageDescription("Field \"{0}\" ({1} visibility) can not be referenced in a specification context of \"{2}\" visibility", "AspectJML", 0);
  public static final MessageDescription	METHOD_VISIBILITY = new MessageDescription("Method \"{0}\" can not be referenced in a specification context of \"{1}\" visibility", "AspectJML", 0);
  public static final MessageDescription	METHOD2_VISIBILITY = new MessageDescription("Method \"{0}\" ({1} visibility) can not be referenced in a specification context of \"{2}\" visibility", "AspectJML", 0);
  public static final MessageDescription	TYPE_VISIBILITY = new MessageDescription("Type \"{0}\" can not be referenced in a specification context of \"{1}\" visibility", "AspectJML", 0);
  public static final MessageDescription	TYPE2_VISIBILITY = new MessageDescription("Type \"{0}\" ({1} visibility) can not be referenced in a specification context of \"{2}\" visibility", "AspectJML", 0);
  public static final MessageDescription	METHOD_SPEC_PRIVACY = new MessageDescription("The access modifier of a method specification cannot allow more access than the method being specified", "AspectJML", 0);
  public static final MessageDescription	REPRESENTS_STATIC_LOCALITY = new MessageDescription("A static depends or represents clause must be declared in the type where the model field on the left-hand side is declared (i.e., in \"{0}\")", "AspectJML", 0);
  public static final MessageDescription	REPRESENTS_LOCALITY = new MessageDescription("A non-static depends or represents clause must be declared in a type descended from (or nested within) the type where the model field on the left-hand side is declared (\"{0}\")", "AspectJML", 0);
  public static final MessageDescription	REPRESENTS_STATIC_FIELD = new MessageDescription("A non-static depends or represents clause must not have a static model field on its left-hand side. This can also happen if you omit the \"instance\" modifier on a model field declaration in an interface", "AspectJML", 0);
  public static final MessageDescription	REPRESENTS_TYPE_MISMATCH = new MessageDescription("The type of right-hand side of a represents clause, \"{0}\", is not assignment-compatible to the type of left-hand side, \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	REPRESENTS_NOT_MODEL = new MessageDescription("The left-hand side of a depends or represents clause must be a reference to a model field", "AspectJML", 0);
  public static final MessageDescription	REDUNDANT_REPRESENTS = new MessageDescription("Model field \"{0}\" has a represents_redundantly clause but no represents clause", "AspectJML", 0);
  public static final MessageDescription	DATA_GROUP_VISIBILITY = new MessageDescription("A field cannot be a member of a data group (\"{0}\") with less visibility", "AspectJML", 0);
  public static final MessageDescription	DATA_GROUP_LOCALITY = new MessageDescription("A non-static field cannot be a member of a static data group (\"{0}\")", "AspectJML", 0);
  public static final MessageDescription	DATA_GROUP_NOT_MODEL = new MessageDescription("The data group \"{0}\" is not a reference to a model (or public or protected or spec_public or spec_protected) field", "AspectJML", 0);
  public static final MessageDescription	CLASS_FLAGS = new MessageDescription("JML modifiers for classes and interfaces can only be: spec_public, spec_protected, model, pure, non_null_by_default, and nullable_by_default", "AspectJML", 0);
  public static final MessageDescription	METHOD_FLAGS = new MessageDescription("JML modifiers for methods can only be: spec_public, spec_protected, model, pure, non_null and nullable", "AspectJML", 0);
  public static final MessageDescription	FIELD_FLAGS = new MessageDescription("JML modifiers for fields can only be: spec_public, spec_protected, model, ghost, instance, non_null, nullable, monitored, and uninitialized", "AspectJML", 0);
  public static final MessageDescription	MONITORED_FOR_STATIC = new MessageDescription("Modifier monitored can be used only for non-static fields", "AspectJML", 0);
  public static final MessageDescription	FLAG_INSTANCE_AND_STATIC = new MessageDescription("Modifiers instance and static must not be used together", "AspectJML", 0);
  public static final MessageDescription	FLAG_SPEC_PUBLIC = new MessageDescription("Modifier spec_public is redundant, because the name is already public", "AspectJML", 0);
  public static final MessageDescription	FLAG_SPEC_PROTECTED = new MessageDescription("Modifier spec_protected is redundant or narrows Java visibility", "AspectJML", 0);
  public static final MessageDescription	FLAG_SPEC_PUBLIC_AND_PROTECTED = new MessageDescription("Modifiers spec_public and spec_protected must not be used together", "AspectJML", 0);
  public static final MessageDescription	FLAG_MODEL_AND_SPEC_PUBLIC = new MessageDescription("Modifier model must not be used together with spec_public or spec_protected", "AspectJML", 0);
  public static final MessageDescription	FLAG_INSTANCE_WITHOUT_MODEL = new MessageDescription("Modifier instance must be used with model or ghost", "AspectJML", 0);
  public static final MessageDescription	FLAG_GHOST_AND_SPEC_PUBLIC = new MessageDescription("Modifier ghost must not be used together with spec_public or spec_protected", "AspectJML", 0);
  public static final MessageDescription	FLAG_MODEL_AND_GHOST = new MessageDescription("Modifiers model and ghost must not be used together", "AspectJML", 0);
  public static final MessageDescription	FLAG_MODEL_AND_FINAL = new MessageDescription("Modifiers model and final cannot be used together in a field declaration", "AspectJML", 0);
  public static final MessageDescription	FLAG_SPEC_PUBLIC_AND_PUBLIC = new MessageDescription("Modifier spec_public public must not be used together with public or protected", "AspectJML", 0);
  public static final MessageDescription	JML_DECLARATION_FLAGS = new MessageDescription("JML declaration flags must be some of: public, protected, private, static, and instance", "AspectJML", 0);
  public static final MessageDescription	JML_FLAGS_STATIC_AND_INSTANCE = new MessageDescription("Modifiers static and instance must not be used together", "AspectJML", 0);
  public static final MessageDescription	JML_FLAGS_MULTIPLE_PRIVACY = new MessageDescription("At most one of the public, protected, and private modifiers is allowed", "AspectJML", 0);
  public static final MessageDescription	NON_PRIVATE_NON_PURE_HELPER = new MessageDescription("A non-pure method or constructor can only be a helper if it has private visibility", "AspectJML", 0);
  public static final MessageDescription	NON_PRIVATE_PURE_HELPER_CONSTRUCTOR = new MessageDescription("A pure constructor can only be a helper if it has private visibility", "AspectJML", 0);
  public static final MessageDescription	NULLITY_MODIFIERS_FOR_NON_REF_TYPE = new MessageDescription("Modifier(s) \"{0}\" can not be applied to a non-reference type \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	DIFFERENT_REFINING_FIELD_TYPE = new MessageDescription("Field \"{0}\" refines a field with a different type \"{2}\" in file \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	DIFFERENT_REFINING_ACCESS = new MessageDescription("{0} member \"{1}\" refines a declaration with {3} visibility in file \"{2}\"", "AspectJML", 0);
  public static final MessageDescription	INVALID_REFINING_MODIFIER = new MessageDescription("{0} member \"{1}\" refines a {2} declaration in file \"{3}\"", "AspectJML", 0);
  public static final MessageDescription	NON_MODEL_FIELD_NOT_DEFINED = new MessageDescription("Field \"{0}\" must be declared as a model field because it was not declared in the \".java\" (or \".class\") file for this type, i.e., in \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	NON_MODEL_METHOD_NOT_DEFINED = new MessageDescription("Method \"{0}\" must be declared as a model method because it was not declared in the interface for this type, i.e., in \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	REFINING_METHOD_RETURN_DIFFERENT = new MessageDescription("Method \"{0}\" refines a method with a different return type \"{2}\" in file \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	REFINING_METHOD_THROWS_DIFFERENT = new MessageDescription("Method \"{0}\" refines a method in file \"{1}\" that does not throw \"{2}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_BOOLEAN_IN_ASSUME = new MessageDescription("A predicate is required in the assume statement, instead of an expression of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	SUBTYPE_OF_TYPE = new MessageDescription("Type expressions are required for both sides of the <: operator; found expressions of types \"{0}\" and \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	TYPE_NAME_IN_TYPE_OF_EXPRESSION = new MessageDescription("A type name can not be used in the \\typeof expression; perhaps, you meant the \\type expression?", "AspectJML", 0);
  public static final MessageDescription	NOT_NON_ARRAY_REFERENCE_TYPE_IN_METHOD_NAME = new MessageDescription("A non-array reference type is required in the method name syntax; found type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_INTEGRAL_EXPRESSION = new MessageDescription("An expression of integral type is required; found an expression of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_REFERENCE_EXPRESSION = new MessageDescription("An expression of reference type is required instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_REFERENCE_EXPRESSION_IN_FIELDS_OF = new MessageDescription("An expression of reference type is required in \\fields_of, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_REFERENCE_TYPE_IN_FIELDS_OF = new MessageDescription("A reference type is required in this form of \\fields_of, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_NON_ARRAY_REFERENCE_TYPE_IN_FIELDS_OF = new MessageDescription("A non-array reference type is required in this form of \\fields_of, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_SUBTYPE_OF_IN_FIELDS_OF = new MessageDescription("Type \"{0}\" is not a subtype of type \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	BAD_TYPE_IN_MEASURED_CLAUSE = new MessageDescription("An expression of integral type is required in the measured_by clause; found an expression of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	BAD_TYPE_IN_DECREASING_STATEMENT = new MessageDescription("An expression of integral type is required in the decreasing statement; found an expression of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	BAD_TYPE_IN_WORKING_SPACE_CLAUSE = new MessageDescription("An expression of integral type is required in the working_space clause; found an expression of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	BAD_TYPE_IN_DURATION_CLAUSE = new MessageDescription("An expression of integral type is required in the duration clause; found an expression of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	BAD_TYPE_IN_SIGNALS_ONLY = new MessageDescription("Cannot use type \"{0}\" in a signals_only clause, since it does not inherit from \"java.lang.Throwable\"", "AspectJML", 0);
  public static final MessageDescription	BAD_TYPE_IN_SIGNALS = new MessageDescription("Cannot use type \"{0}\" in a signals clause, since it does not inherit from \"java.lang.Throwable\"", "AspectJML", 0);
  public static final MessageDescription	UNCAUGHT_EXCEPTION_IN_SIGNALS = new MessageDescription("Exception \"{0}\" does not appear in throws list", "AspectJML", 0);
  public static final MessageDescription	UNINITIALIZED_OLD_VAR = new MessageDescription("old variable \"{0}\" is not initialized", "AspectJML", 0);
  public static final MessageDescription	NOT_REFERENCE_EXPRESSION_IN_REACH = new MessageDescription("An expression of reference type is required in \\reach, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_REFERENCE_TYPE_IN_REACH = new MessageDescription("A reference type is required in this form of \\reach, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_NON_ARRAY_REFERENCE_TYPE_IN_REACH = new MessageDescription("A non-array reference type is required in this form of \\reach, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	DUPLICATE_SAME_PREDICATE = new MessageDescription("Only one requires clause with the \"\\same\" predicate is allowed for each specification case", "AspectJML", 0);
  public static final MessageDescription	NESTED_SAME_PREDICATE = new MessageDescription("The \"\\same\" predicate cannot be part of a nested specification case", "AspectJML", 0);
  public static final MessageDescription	ILLEGAL_SAME_PREDICATE = new MessageDescription("The \"\\same\" predicate cannot be the only precondition for a method; there must be at least one specification case that is not \"\\same\"", "AspectJML", 0);
  public static final MessageDescription	ILLEGAL_CODE_MODIFIER = new MessageDescription("An abstract method cannot have a \"code\" specification", "AspectJML", 0);
  public static final MessageDescription	ILLEGAL_EXTRACT_MODIFIER = new MessageDescription("An abstract method cannot be marked \"extract\"", "AspectJML", 0);
  public static final MessageDescription	NOT_BOOLEAN = new MessageDescription("A boolean valued expression is required in this context", "AspectJML", 0);
  public static final MessageDescription	MULTIPLE_VAR_DECL = new MessageDescription("Variable \"{0}\" is declared multiple times", "AspectJML", 0);
  public static final MessageDescription	NOT_BOOLEAN_IN_QUANTIFIED = new MessageDescription("A boolean expression is required in quantifiers", "AspectJML", 0);
  public static final MessageDescription	NOT_NUMERIC_IN_QUANTIFIED = new MessageDescription("A numeric expression is required in the generalized quantifiers", "AspectJML", 0);
  public static final MessageDescription	SET_COMPREHENSION_TYPE = new MessageDescription("Either JMLObjectSet or JMLValueSet is required; but found type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	ILL_FORMED_SET_COMPREHENSION = new MessageDescription("A boolean expression of the form \"exp.has(var) && pred\" is requred in the set comprehension", "AspectJML", 0);
  public static final MessageDescription	NOT_REFERENCE_SET_MEMBER_TYPE = new MessageDescription("A reference type is required for set member type", "AspectJML", 0);
  public static final MessageDescription	NOT_JMLTYPE_SET_MEMBER_TYPE = new MessageDescription("For a set of type JMLValueSet, a subtype of JMLType is required for its member type, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	RESULT_VOID = new MessageDescription("The \\result expression cannot be used in this method's specification, since the method returns void", "AspectJML", 0);
  public static final MessageDescription	TYPE_IN_NONNULLELEMENTS = new MessageDescription("An expression of non-primitive array type is required in \\nonnullelements, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NOT_TYPE_IN_ELEMTYPE = new MessageDescription("A type valued expression is required in \\elemtype", "AspectJML", 0);
  public static final MessageDescription	NOT_REFERENCE_TYPE_IN_INVARIANT_FOR = new MessageDescription("A class reference expression is required in \\invariant_for.", "AspectJML", 0);
  public static final MessageDescription	NOT_CLASS_TYPE = new MessageDescription("A class or interface type is required in this context: \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	TYPE_UNKNOWN = new MessageDescription("Type \"{0}\" cannot be found", "AspectJML", 0);
  public static final MessageDescription	FRESH_NOT_ALLOWED = new MessageDescription("\"\\fresh\" clause is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	TYPE_IN_FRESH = new MessageDescription("An expression of reference type is required in \\fresh, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	TYPE_IN_SPACE = new MessageDescription("An expression of reference type is required in \\space, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	TYPE_IN_LABELED_EXPRESSION = new MessageDescription("An expression of boolean type is required in this label expression, instead of type \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	LABEL_UNKNOWN = new MessageDescription("Label \"{0}\" is not defined in current statement hierarchy", "AspectJML", 0);
  public static final MessageDescription	NOT_MODIFIED_NOT_ALLOWED = new MessageDescription("\"\\not_modified\" clause is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	NOT_ASSIGNED_NOT_ALLOWED = new MessageDescription("\"\\not_assigned\" clause is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	ONLY_ACCESSED_NOT_ALLOWED = new MessageDescription("\"\\only_accessed\" clause is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	ONLY_CALLED_NOT_ALLOWED = new MessageDescription("\"\\only_called\" clause is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	ONLY_CAPTURED_NOT_ALLOWED = new MessageDescription("\"\\only_captured\" clause is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	ONLY_ASSIGNED_NOT_ALLOWED = new MessageDescription("\"\\only_assigned\" clause is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	OLD_NOT_ALLOWED = new MessageDescription("The \"\\old\" expression is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	PRE_NOT_ALLOWED = new MessageDescription("The \"\\pre\" expression is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	SPACE_NOT_ALLOWED = new MessageDescription("The \"\\space\" expression is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	WORKING_SPACE_NOT_ALLOWED = new MessageDescription("The \"\\working_space\" expression is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	DURATION_NOT_ALLOWED = new MessageDescription("The \"\\duration\" expression is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	INVALID_FIELD_NAME_IN_MAPS_CLAUSE = new MessageDescription("\"{0}\" is not one of the names declared in the preceding field declaration", "AspectJML", 0);
  public static final MessageDescription	WORKING_SPACE_MUST_CONTAIN_METHOD_CALL = new MessageDescription("The spec-expression inside \"\\working_space()\" must be a method call or explict constructor invocation", "AspectJML", 0);
  public static final MessageDescription	DURATION_MUST_CONTAIN_METHOD_CALL = new MessageDescription("The spec-expression inside \"\\duration()\" must be a method call or explict constructor invocation", "AspectJML", 0);
  public static final MessageDescription	RESULT_NOT_ALLOWED = new MessageDescription("The \"\\result\" expression is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	THIS_NOT_ALLOWED = new MessageDescription("\"this\" is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	SUPER_NOT_ALLOWED = new MessageDescription("\"super\" is not allowed in this context", "AspectJML", 0);
  public static final MessageDescription	EQUIVALENCE_TYPE = new MessageDescription("Cannot apply equivalence (or implication) operator to \"{0}\" and \"{1}\"", null, 0);
  public static final MessageDescription	INVALID_FILE_SUFFIX = new MessageDescription("Invalid file suffix \"{0}\"; file suffixes must be one of the following: .refines-java, .java, .java-refined, .refines-spec, .spec, .spec-refined, .refines-jml, .jml, .jml-refined", "AspectJML", 0);
  public static final MessageDescription	INVALID_EXCLUDEFILES_PATTERN_SYNTAX = new MessageDescription("Invalid regular expression syntax (see java.util.regex.Pattern) for --excludefiles option: {0}", "AspectJML", 0);
  public static final MessageDescription	INVALID_SELF_REFINEMENT = new MessageDescription("Invalid suffix in a refinement.  File \"{0}\" may not refine itself.", "AspectJML", 0);
  public static final MessageDescription	INVALID_REFINE_FILE_SUFFIX = new MessageDescription("Invalid suffix sequence in a refinement. File \"{0}\" cannot refine file \"{1}\". \nFile suffixes in refinement sequences are grouped into the following levels: \n  Level 8-- .jml-refined, \n  Level 7-- .spec-refined, \n  Level 6-- .java-refined, \n  Level 5-- .jml, \n  Level 4-- .spec, \n  Level 3-- .java, \n  Level 2-- .refines-jml, \n  Level 1-- .refines-spec, \n  Level 0-- .refines-java.  \nA file with a suffix at a higher level cannot refine one at a lower level if it is the most refined declaration (otherwise the class will not load properly).", "AspectJML", 0);
  public static final MessageDescription	REFINE_FILE_CYCLE = new MessageDescription("Invalid refinement sequence.  File \"{0}\" cannot refine file \"{1}\" because it creates a cycle.", "AspectJML", 0);
  public static final MessageDescription	CLASS_NAME_REFINING_FILENAME = new MessageDescription("Class \"{0}\" is public and its most refined definition must be in a file with same name and not \"{1}\", otherwise this file will not be loaded by the type checker", "AspectJML", 0);
  public static final MessageDescription	INVALID_REFINING_PARAMETER_NAME = new MessageDescription("Method \"{0}\" does not have the same parameter names as the method it refines. Parameter \"{1}\" in file \"{2}\" does not match \"{3}\" in file \"{4}\").", "AspectJML", 0);
  public static final MessageDescription	INVALID_REFINING_PARAMETER_NULLITY = new MessageDescription("The nullity modifier ( {2}) of parameter \"{1}\" of method \"{0}\" differs from the nullity modifier ( {3}) given for this parameter in the refines file \"{4}\"", "AspectJML", 0);
  public static final MessageDescription	METHOD_BODY_NOT_IN_JAVA_FILE = new MessageDescription("The body of a non-model method can only occur in a '.java' file", "AspectJML", 0);
  public static final MessageDescription	MODEL_METHOD_WITH_MORE_THAN_ONE_BODY = new MessageDescription("The body of model method \"{0}\" has already been defined in another file in the refinement chain", "AspectJML", 0);
  public static final MessageDescription	FIELD_WITH_MORE_THAN_ONE_INITIALIZER = new MessageDescription("The initializer of field \"{0}\" has already been defined in another file in the refinement chain", "AspectJML", 0);
  public static final MessageDescription	FIELD_INIT_NOT_IN_JAVA_FILE = new MessageDescription("A field initializer can only occur in a '.java' file", "AspectJML", 0);
  public static final MessageDescription	MODEL_FIELD_WITH_INITIALIZER = new MessageDescription("A model field cannot have an initializer", "AspectJML", 0);
  public static final MessageDescription	EXTRANEOUS_ALSO = new MessageDescription("Method \"{0}\" has a specification beginning with 'also' but does not override or refine anything.", "AspectJML", 1);
  public static final MessageDescription	MISSING_ALSO = new MessageDescription("Method \"{0}\" overrides \"{1}\" but has a specification that does not begin with 'also'.", "AspectJML", 0);
  public static final MessageDescription	MISSING_REFINING_ALSO = new MessageDescription("Method \"{0}\" refines this method in file \"{1}\" but has a specification that does not begin with 'also'.", "AspectJML", 0);
  public static final MessageDescription	RECEIVER_IN_ASSIGNABLE = new MessageDescription("The pseudo variable \"{0}\" is not an assignable field.", "AspectJML", 0);
  public static final MessageDescription	NOT_ASSIGNABLE_FIELD = new MessageDescription("Field \"{0}\" is not assignable by method \"{1}\"; only fields and fields of data groups in set \"{2}\" are assignable", "AspectJML", 0);
  public static final MessageDescription	INVALID_MAPS_CLAUSE = new MessageDescription("A maps clause is not allowed in the declaration of model field \"{0}\".", "AspectJML", 0);
  public static final MessageDescription	INVALID_MODEL_FIELD_IN_ASSIGNABLE = new MessageDescription("A field of a model object, such as \"{0}\", is not assignable.", "AspectJML", 0);
  public static final MessageDescription	AMBIGUOUS_CALLABLE_METHOD = new MessageDescription("Method \"{0}\" is overloaded, therefore, the parameters of that method must be specified to disambiguate the call", "AspectJML", 0);
  public static final MessageDescription	NOT_CALLABLE_METHOD = new MessageDescription("Method \"{0}\" can assign to fields and fields of data groups in set \"{1}\"; therefore it cannot call \"{2}\" because that method can assign to fields in \"{3}\" ", "AspectJML", 0);
  public static final MessageDescription	PURE_AND_ASSIGNABLE = new MessageDescription("A pure method can not have an assignable clause", "AspectJML", 0);
  public static final MessageDescription	PURE_AND_CALLS_NON_PURE = new MessageDescription("Method \"{0}\" does not allow side-effects; thus it cannot call \"{1}\" ", "AspectJML", 0);
  public static final MessageDescription	SYNCHRONIZED_PURE = new MessageDescription("A synchronized method can not be pure", "AspectJML", 0);
  public static final MessageDescription	JAVADOC_FAILURE = new MessageDescription("Failed to parse javadoc comment: \"{0}\"", "AspectJML", 0);
  public static final MessageDescription	NULLABLE_NON_NULL_TOGETHER = new MessageDescription("The modifiers nullable and non_null can not be used together.", "AspectJML", 0);
  public static final MessageDescription	CLASS_LEVEL_NULLABLE_NON_NULL_TOGETHER = new MessageDescription("The modifiers nullable_by_default and non_null_by_default can not be used together.", "AspectJML", 0);
  public static final MessageDescription	MODEL_FIELD_ACCESS = new MessageDescription("Reference to field \"{0}\" matches a model field declared in \"{1}\". A model field can not be referenced in program code.", "AspectJML", 0);
  public static final MessageDescription	GHOST_FIELD_ACCESS = new MessageDescription("Reference to field \"{0}\" matches a ghost field declared in \"{1}\". A ghost field can only be referenced in an annotation.", "AspectJML", 0);
  public static final MessageDescription	CLASS_NOT_DEFINED = new MessageDescription("Class \"{0}\" was declared in \"{1}\" but is not declared in a \".java\" or \".class\" file for this type", "AspectJML", 2);
  public static final MessageDescription	METHOD_NOT_DEFINED = new MessageDescription("Missing method specification -- \"{0}\" was declared in \"{1}\" but is not declared in the interface specifications for this type", "AspectJML", 2);
  public static final MessageDescription	MISSING_REPRESENTS = new MessageDescription("No represents clause found for model field \"{0}\" declared in {1}", "AspectJML", 2);
  public static final MessageDescription	MISSING_REPRESENTS_ERROR = new MessageDescription("No represents clause found for model field \"{0}\" declared in {1}", "AspectJML", 0);
  public static final MessageDescription	METHOD_SPEC_INCONSISTENT = new MessageDescription("All specification blocks for this method are inconsistent", "AspectJML", 3);
  public static final MessageDescription	INVARIANT_FALSE = new MessageDescription("Invariant clause is false or contains a false conjunct", "AspectJML", 3);
  public static final MessageDescription	ASSERTIONS_FOR_MORE_THAN_ONE_VAR = new MessageDescription("The assertions in this declaration apply to more than one field", "AspectJML", 3);
  public static final MessageDescription	BAD_PARAM_MOD_ORDER = new MessageDescription("Recommended style for parameter declared to be final and non_null (or nullable) is for \"final\" to be listed first", "AspectJML", 3);
  public static final MessageDescription	BAD_SPEC_BODY_ORDER = new MessageDescription("Recommended order of specification body clauses is diverges and measured_by, then assignable (modifiable), accessible, callable, and captures, then when, then working_space and duration, then ensures (post), then signals (exsures).", "AspectJML", 3);
  public static final MessageDescription	UNSAFE_ARITHMETIC_OPERATION = new MessageDescription("Unsafe operation \"{0}\" may result in arithmetic overflow. Consider explicitely declaring the math mode for this specification (e.g. spec_bigint_math mode).", "AspectJML", 2);
  public static final MessageDescription	SPEC_DISCARDED_SEMI = new MessageDescription("Behavioral specification(s) for a method discarded because of stray semicolon", "AspectJML", 1);
  public static final MessageDescription	SPEC_DISCARDED_BLOCKEND = new MessageDescription("Behavioral specification(s) for a method discarded because the end of the type declaration block was reached without an intervening method", "AspectJML", 1);
  public static final MessageDescription	SUBCLASSING_CONTRACT = new MessageDescription("Callable or accessible clauses for a non-public (or non-protected) method", "AspectJML", 1);
  public static final MessageDescription	METHOD_NOT_PURE = new MessageDescription("A method that is not pure, \"{0}\", cannot appear in specification expressions", "AspectJML", 0);
  public static final MessageDescription	NO_ASSIGNABLE = new MessageDescription("A heavyweight specification case for a non-pure method has no assignable clause", "AspectJML", 1);
  public static final MessageDescription	NON_MATCHING_PARAMETER_NAME = new MessageDescription("Method \"{0}\" inherits a specification that may be incompatible; it does not have the same parameter names as the method it overrides. Parameter \"{1}\" in file \"{2}\" does not match \"{3}\" in file \"{4}\").", "AspectJML", 3);
  public static final MessageDescription	METHOD_MAY_NOT_PURE = new MessageDescription("A method \"{0}\" may not be pure, but used in an assertion", "AspectJML", 3);
  public static final MessageDescription	PARAMETER_NULLITY_MISMATCH = new MessageDescription("The nullity of parameter \"{0}\" of the overriding method \"{1}\" does not match the nullity of the corresponding parameter in the supertype \"{2}\"", "AspectJML", 0);
  public static final MessageDescription	UNEXPECTED_NULLITY_ANNOTATION = new MessageDescription("Nullity annotation is not allowed in this new expresion", "AspectJML", 0);
  public static final MessageDescription	METHOD_NON_NULL_IN_SUPER = new MessageDescription("Nullable method \"{0}\" is declared non-null in the super class or interface \"{1}\"", "AspectJML", 0);
  public static final MessageDescription	IMPLICIT_NULLITY = new MessageDescription("Field, method or parameter is implicitly declared non-null or nullable", "AspectJML", 1);
  public static final MessageDescription	ARRAY_NULLITY_DECLARATION_MISMATCH = new MessageDescription("Nullable value not allowed in non-null array initializer", "AspectJML", 0);
  public static final MessageDescription	INVALID_SIGNALS_CLAUSE = new MessageDescription("java.lang.Error or subytpes cannot appear in signals clauses", "AspectJML", 0);
  public static final MessageDescription	INVALID_SIGNALS_CLAUSE_VAR_IDENT = new MessageDescription("\"jml$e\" cannot be used as a var identifier in signals clauses", "AspectJML", 0);
  public static final MessageDescription	INVALID_SIGNALS_ONLY_CLAUSE = new MessageDescription("java.lang.Error or subytpes cannot appear in signals_only clauses", "AspectJML", 0);
  public static final MessageDescription	INVALID_METHOD_SPEC_CASES = new MessageDescription("The heavyweight specification of method \"{0}\" must have at least one specification case with the same visibility as the method itself", "AspectJML", 0);
  public static final MessageDescription	PARSING = new MessageDescription("parsing {0}", null, 6);
  public static final MessageDescription	TYPECHECKING = new MessageDescription("typechecking {0}", null, 6);
  public static final MessageDescription	ASSIGNABLE_CHECKING = new MessageDescription("checking assignable clauses of {0}", null, 6);
  public static final MessageDescription	NOT_ADMISSIBLE = new MessageDescription("Expression {0} not admissible", "Admissibility", 0);
  public static final MessageDescription	NOT_ADMISSIBLE_REP_FIELD_PRIVATE = new MessageDescription("A rep field must be declared private", "Admissibility", 0);
  public static final MessageDescription	NOT_ADMISSIBLE_REP_METHOD_PRIVATE = new MessageDescription("A method taking rep parameters or returning a rep object must be declared private", "Admissibility", 0);
  public static final MessageDescription	ADMISSIBILITY_OBJECT_CREATION_NOT_SUPPORTED = new MessageDescription("Object creation not yet supported - parameters and receiver expression are checked", "Admissibility", 1);
  public static final MessageDescription	ADMISSIBILITY_METHOD_CALL_NOT_SUPPORTED = new MessageDescription("Method calls not yet supported - parameters and receiver expression are checked", "Admissibility", 1);
  public static final MessageDescription	ADMISSIBILITY_STATICS_NOT_SUPPORTED = new MessageDescription("Statics not yet supported - in {0}", "Admissibility", 1);
}
