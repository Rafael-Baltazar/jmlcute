/*
 * Copyright (C) 2008-2009 Federal University of Pernambuco and 
 * University of Central Florida
 *
 * This file is part of AJML
 *
 * AJML is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * AJML is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AJML; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: PostconditionMethodAdvice.java,v 1.0 2009/01/18 10:51:36 henriquerebelo Exp $
 * 
 * This file is based on the original $Id: PostconditionMethod.java,v 1.18 2006/02/11 03:06:44 chalin Exp $
 * by Yoonsik Cheon
 */

package org.jmlspecs.ajmlrac;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.jmlspecs.checker.JmlMethodDeclaration;
import org.jmlspecs.checker.JmlTypeDeclaration;
import org.jmlspecs.util.AspectUtil;
import org.multijava.mjc.CClassType;
import org.multijava.mjc.CType;
import org.multijava.mjc.JMethodDeclarationType;

import com.thoughtworks.qdox.model.JavaMethod;

/**
 * A class for generating a postcondition check method as an AspecJ advice. 
 * The postcondition checking code is automatic wrapped with code that checks 
 * inherited postconditions if any, and throws an appropriate exception to signal 
 * a violation if the postcondition is violated at runtime.
 *
 * <p>
 * The class implements a variant of the <em>Template Pattern</em>
 * [GoF95], prescribed in the class {@link AssertionMethod}.
 * </p>
 *
 * @see AssertionMethod
 *
 * @author Henrique Rebelo
 * @version $Revision: 1.0 $
 */

public class PostconditionMethodAdvice extends PreOrPostconditionMethod {

	// ----------------------------------------------------------------------
	// CONSTRUCTORS
	// ----------------------------------------------------------------------

	/** Construct a new <tt>PostconditionMethodAdvice</tt> object.
	 * @param mdecl method for which the postcondition method is generated
	 */
	public PostconditionMethodAdvice(JmlTypeDeclaration typeDecl,
			JmlMethodDeclaration mdecl,
			String restoreMethod)
	{ 
		super(typeDecl, mdecl, restoreMethod);
		this.prefix = MN_CHECK_POST;
		this.methodName = prefix + methodName(mdecl) + "$" + typeDecl.ident();
		this.exceptionToThrow = "JMLExitNormalPostconditionError";
		this.exceptionToXThrow =	"JMLExitExceptionalPostconditionError";
		this.returnType = mdecl.returnType();

		// javadoc to be added to the generated method
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		if(isMethodCrosscutSpecChecking){
			this.javadoc = "/** Generated by AspectJML to check the normal " + 
					"postcondition of\n" + 
					" * members intercepted by " + mdecl.ident() + " pointcut. */";
		}
		else{
			this.javadoc = "/** Generated by AspectJML to check the normal " + 
					"postcondition of\n" + 
					" * method " + mdecl.ident() + ". */";
		}
	}

	// ----------------------------------------------------------------------
	// TRANSLATION
	// ----------------------------------------------------------------------
	public JMethodDeclarationType generate(RacNode stmt) {
		throw new UnsupportedOperationException();
	}


	/** Generate and return a postcondition checking method. Append to the 
	 * body (<tt>stmt</tt>) (1) code to check the inherited postcondition
	 * if any, and (2) code to throw an appropriate exception to notify a
	 * violation if the postcondition is violated at runtime.
	 * 
	 * @param stmt code to evaluate the postcondition; the result is supposed
	 *             to be stored in the variable <code>VN_ASSERTION</code>. 
	 *             A <code>null</code> value means that no postcondition is 
	 *             specified or it is not executable.
	 */
	public JMethodDeclarationType generate(RacNode stmt, String nPostPred,
			List xPostCode, HashMap oldExprs, HashMap oldExprsDecl,
			List preExprs, List preExprsDecl, HashMap oldVarsDecl, 
			String instrumentationType, long visibility, 
			List<CType> exceptionsInSignalsClauses) {
		this.hasOldVariables = AspectUtil.getInstance().hasElementsStoredOldExpressions(oldVarsDecl);
		this.hasOldExpressions = AspectUtil.getInstance().hasElementsStoredOldExpressions(oldExprs);
		this.hasPreExpressions = preExprs.size() > 0;
		StringBuffer code = new StringBuffer("");
		this.exceptionsInSignalsClauses = exceptionsInSignalsClauses;
	
		if (instrumentationType.equals("clientAwareChecking")) {
			if (visibility == ACC_PUBLIC) {
				this.exceptionToThrow = "JMLExitPublicNormalPostconditionError";
				this.exceptionToXThrow =	"JMLExitPublicExceptionalPostconditionError";
			} else if (visibility == ACC_PROTECTED) {
				this.exceptionToThrow = "JMLExitProtectedNormalPostconditionError";
				this.exceptionToXThrow =	"JMLExitProtectedExceptionalPostconditionError";
			} else if (visibility == 0L) { //default
				this.exceptionToThrow = "JMLExitDefaultNormalPostconditionError";
				this.exceptionToXThrow =	"JMLExitDefaultExceptionalPostconditionError";
			} else if (visibility == ACC_PRIVATE) {
				this.exceptionToThrow = "JMLExitPrivateNormalPostconditionError";
				this.exceptionToXThrow =	"JMLExitPrivateExceptionalPostconditionError";
			}
		}
		
		if ( (methodDecl.hasSpecification()) ){
			if(hasPreExpressions || hasOldVariables || hasOldExpressions){
				if( (nPostPred.equals(""))){
					nPostPred = "true";
				}
				code = this.generateNormalAndXPostconditionWithAroundAdvice(nPostPred, xPostCode, oldExprs, oldExprsDecl, preExprs, preExprsDecl, oldVarsDecl, instrumentationType, visibility);
				AspectUtil.getInstance().setAroundAdvice(true);
			}
			else {
				code = this.generateNormalAndXPostCheckWithAfterReturningAndAfterThrowingAdvice(nPostPred, xPostCode, instrumentationType, visibility);
			}
		}
		else{
			if( (!nPostPred.equals(""))){
				if(!nPostPred.equals("true")){
					code = this.generateNormalPostCheckWithAfterReturningAdvice(nPostPred, instrumentationType, visibility);
				}
			}
			
//			if(hasAnyParameterDeclaredNonNull() || this.methodDecl.isDeclaredNonNull()){
				this.setJavadocForXPostMethodAdvice();
				code.append(this.generateXPostcheckWithAfterThrowingAdvice(nPostPred, xPostCode, instrumentationType, visibility));
				code.append("\n");
//			}
		}
		
		return RacParser.parseMethod(code.toString(), stmt);
	}
	
	private boolean hasAnyParameterDeclaredNonNull(){
		boolean result = false;
		for (int i = 0; i < methodDecl.parameters().length; i++) {
			if (methodDecl.parameters()[i].isDeclaredNonNull()) { //NonNull()) {
				result = true;
				break;
			}
		}
		return result;
	}

	private void setJavadocForXPostMethodAdvice() {
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		if(isMethodCrosscutSpecChecking){
			this.javadoc = "/** Generated by AspectJML to check the exceptional " + 
					"postcondition of\n" + 
					" * members intercepted by " + this.methodDecl.ident() + " pointcut. */";
		}
		else{
			this.javadoc = "/** Generated by AspectJML to check the exceptional " + 
					"postcondition of\n" + 
					" * method " + this.methodDecl.ident() + ". */";
		}
	}

	private void setJavadocForNPostAndXPostMethodAdvice() {
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		if(isMethodCrosscutSpecChecking){
			javadoc = "/** Generated by AspectJML to check the normal " +
					"and\n" + 
					" * exceptional postcondition of members intercepted by " + this.methodDecl.ident() + " pointcut. */";
		}
		else{
			javadoc = "/** Generated by AspectJML to check the normal " +
					"and\n" + 
					" * exceptional postcondition of method " + this.methodDecl.ident() + ". */";
		}
		
	}

	private StringBuffer generateNormalAndXPostconditionWithAroundAdvice(
			String nPostPred, List xPostCode,
			HashMap oldExprs, HashMap oldExprsDecl,
			List preExprs, List preExprsDecl, HashMap oldVarsDecl,
			String instrumentationType, long visibility) {
		
		StringBuffer code = null;
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		this.setJavadocForNPostAndXPostMethodAdvice();
		code = this.buildAdviceHeader("NPAndXPAssertionMethodsWithAroundAdvice",instrumentationType, visibility, 
				isMethodCrosscutSpecChecking);
		code.append(" {\n");
		
		JavaMethod jm = AspectUtil.getInstance().getCorrespondingJavaMethodThroughJMLMethod(this.methodDecl.getMethod().owner().getJavaName(), this.methodDecl);
		String methodReturnType = "";
		boolean isFlexibleXCS = false;

		if(jm != null){
			isFlexibleXCS = AspectUtil.getInstance().isXCSFlexible(jm);
		}
		
		if((jm != null) && (!(this.methodDecl.isConstructor()))){
			if(jm.getReturnType().toString().equals(this.methodDecl.returnType().toString())){
				methodReturnType = this.methodDecl.returnType().toString();
			}
			else{
				methodReturnType = jm.getReturnType().toString();
			}
		}
		else{
			methodReturnType = this.methodDecl.returnType().toString();
		}
		
		if(isMethodCrosscutSpecChecking){
			code.append("     String runtimeObjectOrStaticType = \"\";\n");
			code.append("     String methSig = \"\";\n");
			code.append("     if(thisJoinPoint.getKind().equals(thisJoinPoint.CONSTRUCTOR_CALL)){\n");
			code.append("       runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
			code.append("       methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(runtimeObjectOrStaticType));\n");
			code.append("       methSig = methSig.replace(runtimeObjectOrStaticType, runtimeObjectOrStaticType+\".<init>\");\n");
			code.append("     }\n");
			code.append("     else{\n");
			code.append("       if(java.lang.reflect.Modifier.isStatic(thisJoinPoint.getSignature().getModifiers())){\n");
			code.append("          runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
			code.append("       }\n");
			code.append("       else{\n");
			code.append("          if(thisJoinPoint.getThis() != null){\n");
			code.append("            runtimeObjectOrStaticType = thisJoinPoint.getThis().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getThis()));\n");
			code.append("          }\n");
			code.append("          else {\n");
			code.append("            runtimeObjectOrStaticType = thisJoinPoint.getTarget().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getTarget()));\n");
			code.append("          }\n");
			code.append("       }\n");
			code.append("         methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(thisJoinPoint.getSignature().getName()));\n");
			code.append("    }\n");		
		}
		
		String mn = "";
		if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){
			mn = this.methodDecl.getMethod().getJavaName()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
		}
		else{
			mn = "."+this.methodDecl.getMethod().getIdent()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
		}
		String qcode = "";
		if(isMethodCrosscutSpecChecking){
			qcode = this.getQuantifierInnerClasses(nPostPred.replace("object$rac", "rac$result"));
			code.append("    ").append("java.lang.Object").append(" ").append("rac$result");
			code.append(" = ").append("null").append(";\n");
			if(qcode.contains("rac$result")){
				code.append("    final ").append(methodReturnType).append(" ").append("rac$result$qcode;\n");
				qcode = qcode.replace("rac$result", "rac$result$qcode");
			}
		}
		else{
			qcode = this.getQuantifierInnerClasses(nPostPred.replace("object$rac", "rac$result"));
			if( !(methodReturnType.equals("void")) ){
				code.append("    ").append(AspectUtil.processMethSig(methodReturnType)).append(" ").append("rac$result");
				code.append(" = ").append(TransUtils.defaultValue(methodDecl.returnType())).append(";\n");
				if(qcode.contains("rac$result")){
					code.append("    final ").append(AspectUtil.processMethSig(methodReturnType)).append(" ").append("rac$result$qcode;\n");
					qcode = qcode.replace("rac$result", "rac$result$qcode");
				}
			}
			if( methodDecl.isConstructor() && (instrumentationType.equals("callSite") || instrumentationType.equals("clientAwareChecking")) ){
				String classQualifiedName = this.typeDecl.getCClass().getJavaName();
				code.append("    ").append(classQualifiedName).append(" ").append("rac$result");
				code.append(" = ").append(TransUtils.defaultValue(methodDecl.returnType())).append(";\n");
				if(qcode.contains("rac$result")){
        			code.append("    final ").append(this.methodDecl.getMethod().owner().getJavaName()).append(" ").append("rac$result$qcode;\n");
        			qcode = qcode.replace("rac$result", "rac$result$qcode");
        		}
        		else if(qcode.contains("object$rac")){
        			code.append("    final ").append(this.methodDecl.getMethod().owner().getJavaName()).append(" ").append("rac$result$qcode;\n");
        			qcode = qcode.replace("object$rac", "rac$result$qcode");
        		}
			}	
		}
		
		HashMap preconditions = getPreconditions(visibility);
		if (this.hasPreExpressions || this.hasOldVariables || this.hasOldExpressions){
			if(this.hasOldVariables){
				for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext();) {
					int index = (int) iterator.next();
					List oldVarsDeclList = (List)oldVarsDecl.get(index);
					if(oldVarsDeclList != null){
						for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
								.hasNext();) {
							String currentOldVarDecl = (String) iterator2.next();
							code.append("    final "+currentOldVarDecl.substring(0, currentOldVarDecl.indexOf('/'))+";");
							code.append("\n");
						}
					}
				}
			}

			if(this.hasPreExpressions){
				for (Iterator iterator = preExprsDecl.iterator(); iterator.hasNext();) {
					String currentPreExprsDecl = (String) iterator.next();
					code.append("    boolean "+currentPreExprsDecl+";");
					code.append("\n");
				}
			}
			if(this.hasOldExpressions){
				for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext();) {
					int index = (int) iterator.next();
					List oldExprsDeclList = (List)oldExprsDecl.get(index);
					if(oldExprsDeclList != null){
						for (Iterator iterator2 = oldExprsDeclList.iterator(); iterator2
								.hasNext();) {
							String currentOldExprsDecl = (String) iterator2.next();
							code.append("    final "+currentOldExprsDecl);
							code.append("\n");
						}
					}
				}
			}

        	// saving pre-expressions and precondition related old vars
        	boolean canGenerate = false;
        	if(this.hasOldVariables){
        		outerLoop:
        			for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext();) {
        				int index = (int) iterator.next();
        				List oldVarsDeclList = (List)oldVarsDecl.get(index);
        				if(oldVarsDeclList != null){
        					for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
        							.hasNext();) {
        						String currentOldVar = (String) iterator2.next();
        						String [] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
        						String currentOldVarIdent = currentOldVarParts[1];
        						if(AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent)){
        							canGenerate = true;
        							break outerLoop;
        						}
        						if(AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)){
        							canGenerate = true;
        							break outerLoop;
        						}
        					}
        				}
        			}
        	}
        	if (this.hasPreExpressions){
        		for (Iterator iterator = preExprs.iterator(); iterator.hasNext();) {
        			canGenerate = true;
        			break;
        		}
        	}

        	if(canGenerate){
        		code.append("    try {\n");
        		code.append("      // saving pre-expressions and precondition related old vars");
        		code.append("\n");
        		if(this.hasOldVariables){
        			for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext();) {
        				int index = (int) iterator.next();
        				List oldVarsDeclList = (List)oldVarsDecl.get(index);
        				if(oldVarsDeclList != null){
        					for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
        							.hasNext();) {
        						String currentOldVar = (String) iterator2.next();
        						String [] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
        						String currentOldVarIdent = currentOldVarParts[1];
        						if(AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent)){
        							code.append("\t\t"+AspectUtil.changeThisOrSuperRefToAdviceRef((currentOldVar.substring((currentOldVar.indexOf('/')+1))), typeDecl)+";");
        							code.append("\n");
        						}
        						if(AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)){
        							code.append("\t\t"+AspectUtil.changeThisOrSuperRefToAdviceRef((currentOldVar.substring((currentOldVar.indexOf('/')+1))), typeDecl)+";");
        							code.append("\n");
        						}
        					}
        				}
        			}
        		}
        		if (this.hasPreExpressions){
        			for (Iterator iterator = preExprs.iterator(); iterator.hasNext();) {
        				String currentPreExpr = (String) iterator.next();
        				// adding JML quantifierInnerClasses if any
        				code.append(this.getQuantifierInnerClasses(currentPreExpr));
        				code.append("\t\t"+currentPreExpr);
        				code.append("\n");
        			}
        		}
        		code.append("     } catch (Throwable rac$cause) {\n");
        		code.append("          if(rac$cause instanceof JMLAssertionError) {\n");
        		code.append("            throw (JMLAssertionError) rac$cause;\n");
        		code.append("          }\n");
        		code.append("          else {\n");
        		code.append("            throw new JMLEvaluationError(\"\" + rac$cause);\n");
        		code.append("          }\n");
        		code.append("     }");
        		code.append("\n");
        	}
        }

        // saving old expressions or old variables not mentioned within preconditions
        for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext();) {
        	int index = (int) iterator.next();
        	List oldVarsDeclList = (List)oldVarsDecl.get(index);
        	List oldExprsList = (List)oldExprs.get(index);

        	boolean canGenerate = false;
        	if((oldVarsDeclList != null)){
        		for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
        				.hasNext();) {
        			String currentOldVar = (String) iterator2.next();
        			String [] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
        			String currentOldVarIdent = currentOldVarParts[1];
        			if(!AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent) && 
        					!AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)){
        				canGenerate = true;
        				break;
        			}
        		}
        	}
        	if((oldExprsList != null)){
        		for (Iterator iterator2 = oldExprsList.iterator(); iterator2
        				.hasNext();) {
        			canGenerate = true;
        			break;
        		}
        	}

        	if(canGenerate){
        		String precondition = (String)preconditions.get(index);
        		code.append("     if ("+precondition+") {\n");
        		code.append("       try {\n");
        		code.append("       // saving old expressions and old vars related to each spec case\n");
        		if((oldVarsDeclList != null)){
        			for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
        					.hasNext();) {
        				String currentOldVar = (String) iterator2.next();
        				String [] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
        				String currentOldVarIdent = currentOldVarParts[1];
        				if(!AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent) && 
            					!AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)){
        					code.append("        "+AspectUtil.changeThisOrSuperRefToAdviceRef((currentOldVar.substring((currentOldVar.indexOf('/')+1))), typeDecl)+";");
        					code.append("\n");
        				}
        			}
        		}
        		if((oldExprsList != null)){
        			for (Iterator iterator2 = oldExprsList.iterator(); iterator2
        					.hasNext();) {
        				String currentOldExpr = (String) iterator2.next();
        				code.append("        "+AspectUtil.changeThisOrSuperRefToAdviceRef(currentOldExpr, this.typeDecl));
        				code.append("\n");
        			}
        		}
        		code.append("       } catch (Throwable rac$cause) {\n");
        		code.append("          if(rac$cause instanceof JMLAssertionError) {\n");
        		code.append("            throw (JMLAssertionError) rac$cause;\n");
        		code.append("          }\n");
        		code.append("          else {\n");
        		code.append("            throw new JMLEvaluationError(\"\" + rac$cause);\n");
        		code.append("          }\n");
        		code.append("       }\n");
        		code.append("     }").append("\n");
        		code.append("     else {\n");
        		if(this.hasOldVariables){
        			if((oldVarsDeclList != null)){
        				for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
        						.hasNext();) {
        					String currentOldVar = (String) iterator2.next();
        					String [] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
        					String currentOldVarType = currentOldVarParts[0];
        					String currentOldVarIdent = currentOldVarParts[1];
        					if(!AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent) && 
                					!AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)){
        						code.append("      "+currentOldVarIdent+" = "+TransUtils.defaultValue(currentOldVarType)+";\n");
        					}
        				}
        			}
        		}
        		if(this.hasOldExpressions){
        			List oldExprsDeclList = (List)oldExprsDecl.get(index);
        			if((oldExprsList != null)){
        				for (Iterator iterator2 = oldExprsDeclList.iterator(); iterator2
        						.hasNext();) {
        					String currentOldExprsDecl = (String) iterator2.next();
        					String [] currentOldExprsParts = currentOldExprsDecl.replace(";", "").split(" ");
        					String currentOldExprType = currentOldExprsParts[0];
        					String currentOldExprIdent = currentOldExprsParts[1];
        					code.append("      "+currentOldExprIdent+" = "+TransUtils.defaultValue(currentOldExprType)+";\n");
        				}
        			}
        		}
        		code.append("     }\n");
        	}
        }
		
		code.append("    boolean rac$b = true;\n");
		code.append("    try {\n");
		if(isMethodCrosscutSpecChecking){
			code.append("      ").append("rac$result").append(" = ").append(this.buildCallProceed(parameters, instrumentationType, isMethodCrosscutSpecChecking, isFlexibleXCS)).append(";").append("//executing the method\n");
			if(qcode.contains("rac$result")){
				code.append("      ").append("rac$result$qcode").append(" = ").append("rac$result;\n");
			}
		}
		else{
			if( (!(methodReturnType.equals("void"))) || (methodDecl.isConstructor() && (instrumentationType.equals("callSite") || instrumentationType.equals("clientAwareChecking")))){
				code.append("      ").append("rac$result").append(" = ").append(this.buildCallProceed(parameters, instrumentationType, isMethodCrosscutSpecChecking, isFlexibleXCS)).append(";").append("//executing the method\n");
				if(qcode.contains("rac$result")){
					code.append("      ").append("rac$result$qcode").append(" = ").append("rac$result;\n");
				}
			}
			else{
				code.append("      ").append(this.buildCallProceed(parameters,instrumentationType, isMethodCrosscutSpecChecking, isFlexibleXCS)).append(";").append("//executing the method\n");
			}
		}
		
		// adding JML quantifierInnerClasses if any
		code.append(qcode);
		HashMap nPostconditions = getNormalPostconditions(visibility);
		HashMap nPostContexts = getContextForNPost(visibility);
		HashMap nPostTokenRefs = getTokenReferenceForNPost(visibility);
		String nPostContext = "";
		String nPostTokenRef = "";

		for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext();) {
			int index = (int) iterator.next();
			String normalPostcondition = (String) nPostconditions.get(index);
			if(AspectUtil.hasAssertion(normalPostcondition)){
				nPostContext = (String)nPostContexts.get(index);
				nPostTokenRef = (String)nPostTokenRefs.get(index);
				if(nPostContext == null){
					nPostContext = "";
				}
				if(nPostTokenRef == null){
					nPostTokenRef = "";
				}
				if(methodDecl.isConstructor() && (visibility != - 1)){
					code.append("       nPostErrorMsg =  " + this.generateErrorMessage(nPostContext,nPostTokenRef,"NormalPostconditionError", isMethodCrosscutSpecChecking).replace("object$rac", "rac$result")+";\n");
					code.append("       evalErrorMsg = "+this.generateErrorMessage(nPostContext,nPostTokenRef,"NPost_EvaluationError", isMethodCrosscutSpecChecking).replace("object$rac", "rac$result")+";\n");
				}
				else{
					code.append("       nPostErrorMsg =  " + this.generateErrorMessage(nPostContext,nPostTokenRef,"NormalPostconditionError", isMethodCrosscutSpecChecking)+";\n");
					code.append("       evalErrorMsg = "+this.generateErrorMessage(nPostContext,nPostTokenRef,"NPost_EvaluationError", isMethodCrosscutSpecChecking)+";\n");
				}

				String precondition = (String)preconditions.get(index);
				code.append("     if ("+precondition+")");
				code.append("{\n");
				code.append("       try {\n");
				if(methodDecl.isConstructor() && (visibility != - 1)){
					code.append("         rac$b = "+normalPostcondition.replace("object$rac", "rac$result")+";\n");
				}
				else{
					code.append("         rac$b = "+normalPostcondition+";\n");
				}
				code.append("       } catch (JMLNonExecutableException rac$nonExec) {\n");
				code.append("          rac$b = ").append(Main.aRacOptions.mustBeExecutable()).append(";\n");
				code.append("       } catch (Throwable rac$cause) {\n");
				code.append("          if(rac$cause instanceof JMLAssertionError) {\n");
				code.append("            throw (JMLAssertionError) rac$cause;\n");
				code.append("          }\n");
				code.append("          else {\n");
				code.append("            throw new JMLEvaluationError(evalErrorMsg + rac$cause);\n");
				code.append("          }\n");
				code.append("       }\n");

				if(Main.aRacOptions.multipleSpecCaseChecking()){
					if(isMethodCrosscutSpecChecking){
						code.append("     JMLChecker.checkNPostMultipleSpecCaseChecking(rac$b, canThrow, nPostErrorMsg, "+visibility+", runtimeObjectOrStaticType+\".\"+methSig);\n");
					}
					else{
						if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){
							code.append("       JMLChecker.checkNPostMultipleSpecCaseChecking(rac$b, nPostErrorMsg, "+visibility+", \""+mn+"\");\n");
						}
						else{
							code.append("       JMLChecker.checkNPostMultipleSpecCaseChecking(rac$b, nPostErrorMsg, "+visibility+", object$rac.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object$rac))+\""+mn+"\");\n");
						}
					}
				}
				else{
					if(isMethodCrosscutSpecChecking){
						code.append("     JMLChecker.checkNormalPostcondition(rac$b, canThrow, nPostErrorMsg, "+visibility+", runtimeObjectOrStaticType+\".\"+methSig);\n");
					}
					else{
						if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){
							code.append("      JMLChecker.checkNormalPostcondition(rac$b, nPostErrorMsg, "+visibility+", \""+mn+"\");\n");	
						}
						else{
							code.append("      JMLChecker.checkNormalPostcondition(rac$b, nPostErrorMsg, "+visibility+", object$rac.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object$rac))+\""+mn+"\");\n");
						}	
					}
				}
				code.append("     }").append("\n");
			}
		}
			
		code.append("    } catch (Throwable rac$e) {\n");
//		if(isMethodCrosscutSpecChecking){
//			if(exceptionsInSignalsClauses.size() > 0){
//				if(Main.aRacOptions.multipleSpecCaseChecking()){
//					code.append("\t   if(JMLChecker.getXPostconditionError() != null){\n");
//					code.append("\t     rac$e = JMLChecker.getXPostconditionError();\n");
//					code.append("\t     if(((JMLExceptionalPostconditionError)rac$e).getRacCause() != null){\n");
//					int i = 0;
//					for (Iterator<CType> iterator = exceptionsInSignalsClauses.iterator(); iterator
//							.hasNext();) {
//						CType cType = iterator.next();
//						if ( (!cType.toString().equals("java.lang.RuntimeException") &&
//								(!cType.toString().equals("java.lang.Error")))){
//							if(i > 0){
//								code.append("\t       else if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");	
//							}
//							else{
//								code.append("\t       if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");
//							}
//							code.append("\t         java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(\"\\\\b\"+java.util.regex.Pattern.quote(\"jml$e is \") +\n");
//							code.append("\t         java.util.regex.Pattern.quote(\"").append(cType.getCClass().getJavaName()).append("\")+\"\\\\b\");\n");
//							code.append("\t         java.util.regex.Matcher matcher = pattern.matcher(rac$e.getMessage());\n");
//							code.append("\t         if(matcher.find()){\n");
//							code.append("\t           rac$e = ((JMLExceptionalPostconditionError)rac$e).getRacCause();\n");
//							code.append("\t         }\n");
//							code.append("\t       }\n");
//						}	
//						i++;
//					}
//					code.append("\t     }\n");
//					code.append("\t   }\n");
//				}
//				else{
//					code.append("\t   if(rac$e instanceof JMLExceptionalPostconditionError){\n");
//					code.append("\t     if(((JMLExceptionalPostconditionError)rac$e).getRacCause() != null){\n");
//					int i = 0;
//					for (Iterator<CType> iterator = exceptionsInSignalsClauses.iterator(); iterator
//							.hasNext();) {
//						CType cType = iterator.next();
//						if ( (!cType.toString().equals("java.lang.RuntimeException") &&
//								(!cType.toString().equals("java.lang.Error")))){
//							if(i > 0){
//								code.append("\t       else if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");	
//							}
//							else{
//								code.append("\t       if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");
//							}
//							code.append("\t         java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(\"\\\\b\"+java.util.regex.Pattern.quote(\"jml$e is \") +\n");
//							code.append("\t         java.util.regex.Pattern.quote(\"").append(cType.getCClass().getJavaName()).append("\")+\"\\\\b\");\n");
//							code.append("\t         java.util.regex.Matcher matcher = pattern.matcher(rac$e.getMessage());\n");
//							code.append("\t         if(matcher.find()){\n");
//							code.append("\t           rac$e = ((JMLExceptionalPostconditionError)rac$e).getRacCause();\n");
//							code.append("\t         }\n");
//							code.append("\t       }\n");
//						}	
//						i++;
//					}
//					code.append("\t     }\n");
//					code.append("\t   }\n");
//				}
//			}
//		}
		if(this.isStatic || this.methodDecl.isConstructor()){
			code.append("         JMLChecker.rethrowJMLAssertionError(rac$e"+", \""+mn+"\");\n");
		}
		else{
			code.append("         JMLChecker.rethrowJMLAssertionError(rac$e"+", object$rac.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object$rac))+\""+mn+"\");\n");	
		}
		code.append("         rac$b = true;\n");
		code.append("         String rac$ErrorMsg = \"\";\n");
		if(xPostCode.size() == 0) {
			code.append("\n");
		}
		for (Iterator iterator = xPostCode.iterator(); iterator.hasNext();) {
			String signalClause = (String) iterator.next();
			code.append(signalClause);
		}
		if(xPostCode.size() > 0) {
			code.append("\n");
		}

//		code.append(this.xPostRethrowStmt(this.exceptionsInSignalsClauses));
		code.append(this.xPostRethrowStmt());
		code.append("\t\t}");
		if(isMethodCrosscutSpecChecking){
			code.append("\n");
			code.append("    ").append("return rac$result;").append("\n");	
		}
		else{
			if( (!(methodReturnType.equals("void"))) || (methodDecl.isConstructor() && (instrumentationType.equals("callSite") || instrumentationType.equals("clientAwareChecking")))){
				code.append("\n");
				code.append("    ").append("return rac$result;").append("\n");	
			}
			else{
				code.append("\n");
			}
		}
		code.append("\t}").append("\n");
		return code;
	}

	private StringBuffer generateNormalAndXPostCheckWithAfterReturningAndAfterThrowingAdvice(
			String nPostPred, List xPostCode, String instrumentationType, long visibility) {
		StringBuffer code = null;
		if(!nPostPred.equals("")){
			if(!nPostPred.equals("true")){
				code = this.generateNormalPostCheckWithAfterReturningAdvice(nPostPred, instrumentationType, visibility);
			}
			else{
				code = new StringBuffer("");
			}
		}
		else{
			code = new StringBuffer("");
		}
		this.setJavadocForXPostMethodAdvice();
		code.append(this.generateXPostcheckWithAfterThrowingAdvice(nPostPred, xPostCode, instrumentationType, visibility));
		return code;
	}

	private StringBuffer generateNormalPostCheckWithAfterReturningAdvice(String nPostPred, String instrumentationType, long visibility) {
		StringBuffer code;
		String mn = "";
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		
		if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){
			mn = this.methodDecl.getMethod().getJavaName()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
		}
		else{
			mn = "."+this.methodDecl.getMethod().getIdent()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
		}
		code = this.buildAdviceHeader("NPAssertionMethodWithAfterReturningAdvice",instrumentationType, visibility, isMethodCrosscutSpecChecking);
		code.append(" {\n");
		if(isMethodCrosscutSpecChecking){
			code.append("     String runtimeObjectOrStaticType = \"\";\n");
			code.append("     String methSig = \"\";\n");
			code.append("     if(thisJoinPoint.getKind().equals(thisJoinPoint.CONSTRUCTOR_CALL)){\n");
			code.append("       runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
			code.append("       methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(runtimeObjectOrStaticType));\n");
			code.append("       methSig = methSig.replace(runtimeObjectOrStaticType, runtimeObjectOrStaticType+\".<init>\");\n");
			code.append("     }\n");
			code.append("     else{\n");
			code.append("       if(java.lang.reflect.Modifier.isStatic(thisJoinPoint.getSignature().getModifiers())){\n");
			code.append("          runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
			code.append("       }\n");
			code.append("       else{\n");
			code.append("          if(thisJoinPoint.getThis() != null){\n");
			code.append("            runtimeObjectOrStaticType = thisJoinPoint.getThis().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getThis()));\n");
			code.append("          }\n");
			code.append("          else {\n");
			code.append("            runtimeObjectOrStaticType = thisJoinPoint.getTarget().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getTarget()));\n");
			code.append("          }\n");
			code.append("       }\n");
			code.append("         methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(thisJoinPoint.getSignature().getName()));\n");
			code.append("    }\n");		
		}
		// adding JML quantifierInnerClasses if any
		code.append(this.getQuantifierInnerClasses(nPostPred));
		code.append("     String nPostErrorMsg =  \"\";\n");
		code.append("     String evalErrorMsg = \"\";\n");
		code.append("     boolean rac$b = true;\n");
		
		HashMap preconditions = getPreconditions(visibility);
		HashMap nPostconditions = getNormalPostconditions(visibility);
		HashMap nPostContexts = getContextForNPost(visibility);
		HashMap nPostTokenRefs = getTokenReferenceForNPost(visibility);
		String nPostContext = "";
		String nPostTokenRef = "";

		for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext();) {
			int index = (int) iterator.next();
			String normalPostcondition = (String) nPostconditions.get(index);
			if(AspectUtil.hasAssertion(normalPostcondition)){
				nPostContext = (String)nPostContexts.get(index);
				nPostTokenRef = (String)nPostTokenRefs.get(index);
				if(nPostContext == null){
					nPostContext = "";
				}
				if(nPostTokenRef == null){
					nPostTokenRef = "";
				}
				code.append("       nPostErrorMsg =  " + this.generateErrorMessage(nPostContext,nPostTokenRef,"NormalPostconditionError", isMethodCrosscutSpecChecking)+";\n");
				code.append("       evalErrorMsg = "+this.generateErrorMessage(nPostContext,nPostTokenRef,"NPost_EvaluationError", isMethodCrosscutSpecChecking)+";\n");

				String precondition = (String)preconditions.get(index);
				code.append("     if ("+precondition+")");
				code.append("{\n");
				code.append("       try {\n");
				code.append("         rac$b = "+normalPostcondition+";\n");
				code.append("       } catch (JMLNonExecutableException rac$nonExec) {\n");
				code.append("          rac$b = ").append(Main.aRacOptions.mustBeExecutable()).append(";\n");
				code.append("       } catch (Throwable rac$cause) {\n");
				code.append("          if(rac$cause instanceof JMLAssertionError) {\n");
				code.append("            throw (JMLAssertionError) rac$cause;\n");
				code.append("          }\n");
				code.append("          else {\n");
				code.append("            throw new JMLEvaluationError(evalErrorMsg + rac$cause);\n");
				code.append("          }\n");
				code.append("       }\n");

				if(Main.aRacOptions.multipleSpecCaseChecking()){
					if(isMethodCrosscutSpecChecking){
						code.append("       JMLChecker.checkNPostMultipleSpecCaseChecking(rac$b, nPostErrorMsg, "+visibility+", runtimeObjectOrStaticType+\".\"+methSig);\n");
					}
					else{
						if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){		
							code.append("       JMLChecker.checkNPostMultipleSpecCaseChecking(rac$b, nPostErrorMsg, "+visibility+", \""+mn+"\");\n");	
						}
						else{
							code.append("       JMLChecker.checkNPostMultipleSpecCaseChecking(rac$b, nPostErrorMsg, "+visibility+", object$rac.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object$rac))+\""+mn+"\");\n");
						}
					}
				}
				else{
					if(isMethodCrosscutSpecChecking){
						code.append("       JMLChecker.checkNormalPostcondition(rac$b, nPostErrorMsg, "+visibility+", runtimeObjectOrStaticType+\".\"+methSig);\n");
					}
					else{
						if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){	
							code.append("      JMLChecker.checkNormalPostcondition(rac$b, nPostErrorMsg, "+visibility+", \""+mn+"\");\n");	
						}
						else{
							code.append("      JMLChecker.checkNormalPostcondition(rac$b, nPostErrorMsg, "+visibility+", object$rac.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object$rac))+\""+mn+"\");\n");
						}	
					}
				}
				code.append("     }").append("\n");
			}
		}
		code.append("\n");
		code.append("   }").append("\n");
		return code;
	}

	/**
	 * @param jmlMemberDeclaration
	 * @param cmethodSet
	 * @return
	 */
	private StringBuffer generateXPostcheckWithAfterThrowingAdvice(String nPostPred, List xPostCode, String instrumentationType, long visibility) {
		StringBuffer code;
		String mn = "";
		boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
		
		if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){
			mn = this.methodDecl.getMethod().getJavaName()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
		}
		else{
			mn = "."+this.methodDecl.getMethod().getIdent()+AspectUtil.generateMethodParameters(this.parameters, false).toString();
		}

		code = this.buildAdviceHeader("XPAssertionMethodWithAfterThrowingAdvice",instrumentationType, visibility, 
				isMethodCrosscutSpecChecking); 
		code.append(" {\n");
//		if(isMethodCrosscutSpecChecking){
//			if(exceptionsInSignalsClauses.size() > 0){
//				if(Main.aRacOptions.multipleSpecCaseChecking()){
//					code.append("\t   if(JMLChecker.getXPostconditionError() != null){\n");
//					code.append("\t     rac$e = JMLChecker.getXPostconditionError();\n");
//					code.append("\t     if(((JMLExceptionalPostconditionError)rac$e).getRacCause() != null){\n");
//					int i = 0;
//					for (Iterator<CType> iterator = exceptionsInSignalsClauses.iterator(); iterator
//							.hasNext();) {
//						CType cType = iterator.next();
//						if ( (!cType.toString().equals("java.lang.RuntimeException") &&
//								(!cType.toString().equals("java.lang.Error")))){
//							if(i > 0){
//								code.append("\t       else if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");	
//							}
//							else{
//								code.append("\t       if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");
//							}
//							code.append("\t         java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(\"\\\\b\"+java.util.regex.Pattern.quote(\"jml$e is \") +\n");
//							code.append("\t         java.util.regex.Pattern.quote(\"").append(cType.getCClass().getJavaName()).append("\")+\"\\\\b\");\n");
//							code.append("\t         java.util.regex.Matcher matcher = pattern.matcher(rac$e.getMessage());\n");
//							code.append("\t         if(matcher.find()){\n");
//							code.append("\t           rac$e = ((JMLExceptionalPostconditionError)rac$e).getRacCause();\n");
//							code.append("\t         }\n");
//							code.append("\t       }\n");
//						}	
//						i++;
//					}
//					code.append("\t     }\n");
//					code.append("\t   }\n");
//				}
//				else{
//					code.append("\t   if(rac$e instanceof JMLExceptionalPostconditionError){\n");
//					code.append("\t     if(((JMLExceptionalPostconditionError)rac$e).getRacCause() != null){\n");
//					int i = 0;
//					for (Iterator<CType> iterator = exceptionsInSignalsClauses.iterator(); iterator
//							.hasNext();) {
//						CType cType = iterator.next();
//						if ( (!cType.toString().equals("java.lang.RuntimeException") &&
//								(!cType.toString().equals("java.lang.Error")))){
//							if(i > 0){
//								code.append("\t       else if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");	
//							}
//							else{
//								code.append("\t       if(((JMLExceptionalPostconditionError)rac$e).getRacCause() instanceof ").append(cType.getCClass().getJavaName().replace("$", ".")).append("){\n");
//							}
//							code.append("\t         java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(\"\\\\b\"+java.util.regex.Pattern.quote(\"jml$e is \") +\n");
//							code.append("\t         java.util.regex.Pattern.quote(\"").append(cType.getCClass().getJavaName()).append("\")+\"\\\\b\");\n");
//							code.append("\t         java.util.regex.Matcher matcher = pattern.matcher(rac$e.getMessage());\n");
//							code.append("\t         if(matcher.find()){\n");
//							code.append("\t           rac$e = ((JMLExceptionalPostconditionError)rac$e).getRacCause();\n");
//							code.append("\t         }\n");
//							code.append("\t       }\n");
//						}	
//						i++;
//					}
//					code.append("\t     }\n");
//					code.append("\t   }\n");
//				}
//			}
//		}
		if(isMethodCrosscutSpecChecking){
			code.append("     String runtimeObjectOrStaticType = \"\";\n");
			code.append("     String methSig = \"\";\n");
			code.append("     if(thisJoinPoint.getKind().equals(thisJoinPoint.CONSTRUCTOR_CALL)){\n");
			code.append("       runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
			code.append("       methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(runtimeObjectOrStaticType));\n");
			code.append("       methSig = methSig.replace(runtimeObjectOrStaticType, runtimeObjectOrStaticType+\".<init>\");\n");
			code.append("     }\n");
			code.append("     else{\n");
			code.append("       if(java.lang.reflect.Modifier.isStatic(thisJoinPoint.getSignature().getModifiers())){\n");
			code.append("          runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
			code.append("       }\n");
			code.append("       else{\n");
			code.append("          if(thisJoinPoint.getThis() != null){\n");
			code.append("             runtimeObjectOrStaticType = thisJoinPoint.getThis().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getThis()));\n");
			code.append("          }\n");
			code.append("          else {\n");
			code.append("             runtimeObjectOrStaticType = thisJoinPoint.getTarget().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getTarget()));\n");
			code.append("          }\n");
			code.append("       }\n");
			code.append("         methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(thisJoinPoint.getSignature().getName()));\n");
			code.append("    }\n");		
		}
		if(!Main.aRacOptions.multipleSpecCaseChecking()){
			if(isMethodCrosscutSpecChecking){
				code.append("         JMLChecker.rethrowJMLAssertionError(rac$e"+", runtimeObjectOrStaticType+\".\"+methSig);\n");	
			}
			else{
				if(this.methodDecl.isStatic() || this.methodDecl.isConstructor()){
					code.append("         JMLChecker.rethrowJMLAssertionError(rac$e"+", \""+mn+"\");\n");
				}
				else{
					code.append("         JMLChecker.rethrowJMLAssertionError(rac$e"+", object$rac.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(object$rac))+\""+mn+"\");\n");	
				}
			}
		}
		
		code.append("         boolean rac$b = true;\n");
		code.append("         String rac$ErrorMsg = \"\";\n");
		
		for (Iterator iterator = xPostCode.iterator(); iterator.hasNext();) {
			String signalClause = (String) iterator.next();
			code.append(signalClause);
		}
		if(xPostCode.size() > 0) {
			code.append("\n");
		}

//		if(isMethodCrosscutSpecChecking){
//			if(exceptionsInSignalsClauses.size() > 0){
//				for (Iterator<CType> iterator = exceptionsInSignalsClauses.iterator(); iterator
//						.hasNext();) {
//					CType cType = iterator.next();
//					if ( (!cType.toString().startsWith("java.lang"))){
//						code.append("\t\t\t if (" + VN_EXCEPTION);
//						code.append(       " instanceof ").append(cType.toString().replace("$", ".")).append(") {\n");
//						if(Main.aRacOptions.multipleSpecCaseChecking()){
//							code.append("\t\t\t   JMLChecker.resetXPostconditionError();\n");
//						}
//						code.append("\t\t\t   throw new JMLInternalRuntimeException(("+cType.toString().replace("$", ".")+")" + VN_EXCEPTION + ");\n");
//						code.append("\t\t\t }\n");
//					}	
//				}
//			}
//		}
		
		// code responsible to ensure the exception introduction pattern functionality by Laddad --- [[[hemr]]]
		CClassType exceptions[] = this.methodDecl.getExceptions();
		if(exceptions.length > 0){
			for (int i = 0; i < exceptions.length; i++) {
				CClassType cType = exceptions[i];
				// complementing exception signals set --- [[[hemr]]]
				AspectUtil.getInstance().appendExceptionInSignalsClauseInCompilationUnit(cType);
			}
		}
		code.append("\t }").append("\n");

		return code;
	}

	// ----------------------------------------------------------------------
	// DATA MEMBERS
	// ----------------------------------------------------------------------

	/** Return type of the method declaration */
	protected CType returnType;

	protected boolean hasPreExpressions;

	protected boolean hasOldVariables;

	protected boolean hasOldExpressions;
	
	private String exceptionToXThrow;
	
	private List<CType> exceptionsInSignalsClauses;

}
